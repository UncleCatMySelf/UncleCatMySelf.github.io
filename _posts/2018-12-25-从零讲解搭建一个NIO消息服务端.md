---
layout:       post
title:        从零讲解搭建一个NIO消息服务端
subtitle:     Netty知识点
date:         2018-12-25
author:       MySelf | 猫叔
header-img:   img/elage.jpg
catelog:      true
tags:
    - Netty
    - InChat
---

> 本文首发于本博客，如需转载，请申明出处.

## 假设

假设你已经了解并实现过了一些OIO消息服务端，并对异步消息服务端更有兴趣，那么本文或许能带你更好的入门，并了解JDK部分源码的关系流程，正如题目所说，笔者将竟可能还原，以初学者能理解的角度，讲诉并构建一个NIO消息服务端。

## 启动通道并注册选择器


### 启动模式


感谢Java一直在持续更新，对应的各个API也做得越来越好了，我们本次生成 **服务端套接字通道** 也是使用到JDK提供的一个方式 **open** ，我们将启动一个 **ServerSocketChannel** ，他是一个 **支持同步异步模式** 的 **服务端套接字通道** 。

它是一个抽象类，官方给了推荐的方式 **open** 来开启一个我们需要的 **服务端套接字通道实例** 。（如下的官方源码相关注释）

```java
/**
 * A selectable channel for stream-oriented listening sockets.
 */
 public abstract class ServerSocketChannel
    extends AbstractSelectableChannel
    implements NetworkChannel
{
    /**
     * Opens a server-socket channel.
     */
    public static ServerSocketChannel open() throws IOException {
        return SelectorProvider.provider().openServerSocketChannel();
    }
}
```

那么好了，我们现在可以确定我们第一步的代码是什么样子的了！没错，和你想象中的一样，这很简单。

```java
public class NioServer {

    public void server(int port) throws IOException{
        //1、打开服务器套接字通道
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    }
}
```

本节的重点是 **启动模式** ，那么这意味着，我们需要向 **ServerSocketChannel** 进行标识，那么它是否提供了对用的方法设置 **同步异步（阻塞非阻塞）** 呢？

这很明显，它是提供的，这也是它的核心功能之一，其实应该是它继承的 **父抽象类AbstractSelectableChannel** 的实现方法： **configgureBlocking（Boolean）**，这个方法将标识我们的 **服务端套接字通道** 是否阻塞模式。（如下的官方源码相关注释）

```java
/**
 * Base implementation class for selectable channels.
 */
 public abstract class AbstractSelectableChannel
    extends SelectableChannel
{
    /**
     * Adjusts this channel's blocking mode.
     */
    public final SelectableChannel configureBlocking(boolean block)
        throws IOException
    {
        synchronized (regLock) {
            if (!isOpen())
                throw new ClosedChannelException();
            if (blocking == block)
                return this;
            if (block && haveValidKeys())
                throw new IllegalBlockingModeException();
            implConfigureBlocking(block);
            blocking = block;
        }
        return this;
    }
}
```

那么，我们现在可以进行 **启动模式的配置** 了，读者很聪明。我们的项目Demo可以这样写： **false为非阻塞模式、true为阻塞模式** 。

```java
public class NioServer {

    public void server(int port) throws IOException{
        //1、打开服务器套接字通道
        ServerSocketChannel serverSocketzhannel = ServerSocketChannel.open();
        //2、设定为非阻塞、调整此通道的阻塞模式。
        serverSocketChannel.configureBlocking(false);
    }
}
```

> 若未配置阻塞模式，**注册选择器** 会报 `java.nio.channels.IllegalBlockingModeException` 异常，相关将于该小节大致讲解说明。

### 套接字地址端口绑定

做过消息通讯服务器的朋友应该都清楚，我们需要向服务端 **指定IP与端口** ，即使是NIO服务器也是一样的，否则，我们的客户端会报 `java.net.ConnectException: Connection refused: connect` 异常

对于NIO的地址端口绑定，我们也需要用到 **ServerSocket服务器套接字** 。我们知道在写OIO服务端的时候，我们可能仅仅需要写一句即可，如下。

```java
    //将服务器绑定到指定端口
    final ServerSocket socket = new ServerSocket(port);
```

当然，JDK在实现NIO的时候就已经想到了，同样，我们可以使用 **服务器套接字通道** 来获取一个 **ServerSocket服务器套接字** 。这时的它并没有绑定端口，我们需要对应绑定地址，这个类自身就有一个 **bind** 方法。（如下源码相关注释）

```java
/**
 * This class implements server sockets. A server socket waits for
 * requests to come in over the network. It performs some operation
 * based on that request, and then possibly returns a result to the requester.
 */
public class ServerSocket implements java.io.Closeable {
    /**
     *
     * Binds the {@code ServerSocket} to a specific address
     * (IP address and port number).
     */
     public void bind(SocketAddress endpoint) throws IOException {
        bind(endpoint, 50);
    }
}
```

通过源码，我们知道，**绑定iP与端口** 需要一个SocketAddress类，我们仅需要将 **IP与端口配置到对应的SocketAddress类** 中即可。其实JDK中，已经有了一个更加方便且继承了SocketAddress的类：**InetSocketAddress**。

InetSocketAddress有一个需要一个port为参数的构造方法，它将创建 **一个ip为通配符、端口为指定值的套接字地址** 。这很方便我们的开发，对吧？(如下源码相关注释)

```java
/**
 *
 * This class implements an IP Socket Address (IP address + port number)
 * It can also be a pair (hostname + port number), in which case an attempt
 * will be made to resolve the hostname. If resolution fails then the address
 * is said to be <I>unresolved</I> but can still be used on some circumstances
 * like connecting through a proxy.
 */
 public class InetSocketAddress
    extends SocketAddress
{
    /**
     * Creates a socket address where the IP address is the wildcard address
     * and the port number a specified value.
     */
     public InetSocketAddress(int port) {
        this(InetAddress.anyLocalAddress(), port);
    }
}
```

好了，那么接下来我们的项目代码可以继续添加绑定IP与端口了，我想聪明的你应该有所感觉了。

```java
public class NioServer {

    public void server(int port) throws IOException{
        //1、打开服务器套接字通道
        ServerSocketChannel serverSocketzhannel = ServerSocketChannel.open();
        //2、设定为非阻塞、调整此通道的阻塞模式。
        serverSocketChannel.configureBlocking(false);
        //3、检索与此通道关联的服务器套接字。
        ServerSocket serverSocket = serverSocketChannel.socket();
        //4、此类实现 ip 套接字地址 (ip 地址 + 端口号) 
        InetSocketAddress address = new InetSocketAddress(port);
        //5、将服务器绑定到选定的套接字地址
        serverSocket.bind(address);
    }
}
```

正如开头我们所说的，你的项目中不添加3-5环节的代码并没有问题，但是当客户端接入时，则会报错，因为客户端将要 **接入的地址是连接不到的** ，如会报这样的错误。

```js
java.net.ConnectException: Connection refused: connect
	at sun.nio.ch.Net.connect0(Native Method)
	at sun.nio.ch.Net.connect(Net.java:457)
	at sun.nio.ch.Net.connect(Net.java:449)
	at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:647)
	at com.github.myself.WebClient.main(WebClient.java:16)
```

### 注册选择器

接下来会是 **NIO实现的重点** ，可能有点难理解，如果希望大家能一次理解，完全深入有点难讲明白，不过先大致点一下。

首先要先介绍以下JDK实现NIO的核心：**多路复用器（Selector）——选择器**

先简单并抽象的理解下，Java通过 **选择器来实现处理多个Channel链接** ，将空闲未进行数据操作的搁置，优先执行有需求的数据传输，即 **通过一个选择器来选择谁需要谁不需要使用共享的线程** 。

由此，理所当然，这样的选择器应该也有Java自己定义的获取方法， 其自身的 **open** 就是启动一个这样的选择器。（如下源码相关注释）

```java
/**
 * A multiplexor of {@link SelectableChannel} objects.
 */
 public abstract class Selector implements Closeable {
     /**
     * Opens a selector.
     *
     public static Selector open() throws IOException {
        return SelectorProvider.provider().openSelector();
     }
 }
```

那么现在，我们还要考虑一件事情，我们的 **服务器套接字通道** 要如何与 **选择器** 相关联呢？

**ServerSocketChannel** 有一个注册的方法，这个方法就是将它们两个进行了关联，同时这个注册方法 **除了关联选择器外，还标识了注册的状态** ，让我们先看看源码吧。


> 以下的 ServerSocketChannel 继承 ---》 AbstractSelectableChannel 继承 ---》 SelectableChannel


```java
/**
 * A channel that can be multiplexed via a {@link Selector}.
 */
 public abstract class SelectableChannel
    extends AbstractInterruptibleChannel
    implements Channel
{
    /**
     * Registers this channel with the given selector, returning a selection
     * key.
     */
     public final SelectionKey register(Selector sel, int ops)
        throws ClosedChannelException
    {
        return register(sel, ops, null);
    }
}
```

我们一般需要将选择器注册上去，并将 **ServerSocketChannel** 标识为 **接受连接** 的状态。我们先看看我们的项目代码应该如何写。

```java
public class NioServer {

    public void server(int port) throws IOException{
        //1、打开服务器套接字通道
        ServerSocketChannel serverSocketzhannel = ServerSocketChannel.open();
        //2、设定为非阻塞、调整此通道的阻塞模式。
        serverSocketChannel.configureBlocking(false);
        //3、检索与此通道关联的服务器套接字。
        ServerSocket serverSocket = serverSocketChannel.socket();
        //4、此类实现 ip 套接字地址 (ip 地址 + 端口号) 
        InetSocketAddress address = new InetSocketAddress(port);
        //5、将服务器绑定到选定的套接字地址
        serverSocket.bind(address);
        //6、打开Selector来处理Channel
        Selector selector = Selector.open();
        //7、将ServerSocket注册到Selector已接受连接，注册会判断是否为非阻塞模式
        SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
    }
}
```

**注意：** 我们前面说到，如果 **ServerSocketChannel** 没有启动非阻塞模式，那么我们在启动的时候会报 `java.lang.IllegalArgumentException` 异常，这是为什么呢？ 我想我们可能需要更深入底层去看看 **register** 这个方法（如下源码注释）

```java
/**
 * Base implementation class for selectable channels.
 */
 public abstract class AbstractSelectableChannel
    extends SelectableChannel
{
    /**
     * Registers this channel with the given selector, returning a selection key.
     */
    public final SelectionKey register(Selector sel, int ops,
                                       Object att)
        throws ClosedChannelException
    {
        synchronized (regLock) {
            if (!isOpen())
                throw new ClosedChannelException();
            if ((ops & ~validOps()) != 0)
                throw new IllegalArgumentException();
            if (blocking)
                throw new IllegalBlockingModeException();
            SelectionKey k = findKey(sel);
            if (k != null) {
                k.interestOps(ops);
                k.attach(att);
            }
            if (k == null) {
                // New registration
                synchronized (keyLock) {
                    if (!isOpen())
                        throw new ClosedChannelException();
                    k = ((AbstractSelector)sel).register(this, ops, att);
                    addKey(k);
                }
            }
            return k;
        }
    }
}
```

我想我们终于真相大白了，原来注册这个方法会对 **ServerSocketChannel** 的一系列参数进行 **校验** ，只有通过，才能注册成功，所以我们也明白了，为什么 **非阻塞是false**，同时我们也可以看到，它还对我们所给的标识做了校验，一点要优先注册 **接受连接（OP_ACCEPT）** 这个状态才行，不然依旧会报 `java.lang.IllegalArgumentException` 异常。

这里解释一下，之所以只接受 **OP_ACCEPT** ，是因为如果没有一个接受其他链接的主服务，那么通信根本无从说起，同时这样的标识在我们的NIO服务端中 **只允许标识一次（一个ServerSocketChannel）** 。 

可能大家还会好奇有什么标识，我想源码的说明确实写的很清楚了。

```java
/**
 * Operation-set bit for read operations.
 */
 public static final int OP_READ = 1 << 0;

/**
 * Operation-set bit for write operations.
 */
 public static final int OP_WRITE = 1 << 2;

/**
 * Operation-set bit for socket-connect operations.
 */
 public static final int OP_CONNECT = 1 << 3;

/**
 * Operation-set bit for socket-accept operations.
 */
 public static final int OP_ACCEPT = 1 << 4;
```

好了，这里给一个调试截图，希望大家也可以慢慢的摸索一下。

![Image Text](https://raw.githubusercontent.com/UncleCatMySelf/img-myself/master/img/inchat/%E8%B0%83%E8%AF%95.png)

> 注意这里的服务端并没有构建完成哦，我们还需要下面的几个步骤。

## NIO选择实例与兴趣点

### 客户端代码



### 准备IO接入操作

### 选择键集合操作

## 回顾

## 个人相关项目

![Image text](https://raw.githubusercontent.com/UncleCatMySelf/img-myself/master/img/inchat/logo.png)

[InChat ： 一个轻量级、高效率的支持多端（应用与硬件Iot）的异步网络应用通讯框架](https://github.com/UncleCatMySelf/InChat)